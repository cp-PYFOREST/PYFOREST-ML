% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
%
\documentclass[
  letterpaper,
  DIV=11,
  numbers=noendperiod]{scrartcl}

\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\setlength{\emergencystretch}{3em} % prevent overfull lines
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
% Make \paragraph and \subparagraph free-standing
\ifx\paragraph\undefined\else
  \let\oldparagraph\paragraph
  \renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
  \let\oldsubparagraph\subparagraph
  \renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{241,243,245}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.40,0.45,0.13}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\BuiltInTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\ExtensionTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.28,0.35,0.67}{#1}}
\newcommand{\ImportTok}[1]{\textcolor[rgb]{0.00,0.46,0.62}{#1}}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\NormalTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.68,0.00,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{\textcolor[rgb]{0.00,0.23,0.31}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.07,0.07,0.07}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.13,0.47,0.30}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}\usepackage{longtable,booktabs,array}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\KOMAoption{captions}{tableheading}
\makeatletter
\makeatother
\makeatletter
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\AtBeginDocument{%
\ifdefined\contentsname
  \renewcommand*\contentsname{Table of contents}
\else
  \newcommand\contentsname{Table of contents}
\fi
\ifdefined\listfigurename
  \renewcommand*\listfigurename{List of Figures}
\else
  \newcommand\listfigurename{List of Figures}
\fi
\ifdefined\listtablename
  \renewcommand*\listtablename{List of Tables}
\else
  \newcommand\listtablename{List of Tables}
\fi
\ifdefined\figurename
  \renewcommand*\figurename{Figure}
\else
  \newcommand\figurename{Figure}
\fi
\ifdefined\tablename
  \renewcommand*\tablename{Table}
\else
  \newcommand\tablename{Table}
\fi
}
\@ifpackageloaded{float}{}{\usepackage{float}}
\floatstyle{ruled}
\@ifundefined{c@chapter}{\newfloat{codelisting}{h}{lop}}{\newfloat{codelisting}{h}{lop}[chapter]}
\floatname{codelisting}{Listing}
\newcommand*\listoflistings{\listof{codelisting}{List of Listings}}
\makeatother
\makeatletter
\@ifpackageloaded{caption}{}{\usepackage{caption}}
\@ifpackageloaded{subcaption}{}{\usepackage{subcaption}}
\makeatother
\makeatletter
\@ifpackageloaded{tcolorbox}{}{\usepackage[many]{tcolorbox}}
\makeatother
\makeatletter
\@ifundefined{shadecolor}{\definecolor{shadecolor}{rgb}{.97, .97, .97}}
\makeatother
\makeatletter
\makeatother
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\urlstyle{same} % disable monospaced font for URLs
\hypersetup{
  colorlinks=true,
  linkcolor={blue},
  filecolor={Maroon},
  citecolor={Blue},
  urlcolor={Blue},
  pdfcreator={LaTeX via pandoc}}

\author{}
\date{}

\begin{document}
\ifdefined\Shaded\renewenvironment{Shaded}{\begin{tcolorbox}[enhanced, borderline west={3pt}{0pt}{shadecolor}, sharp corners, boxrule=0pt, breakable, interior hidden, frame hidden]}{\end{tcolorbox}}\fi

\hypertarget{create-individual-deforestation-files-from-hansen-dataset}{%
\section{Create Individual Deforestation Files From Hansen
Dataset}\label{create-individual-deforestation-files-from-hansen-dataset}}

The purpose of this notebook is two fold: 1. Extract pixels:Takes the
`lossyear' image from the Hansen et al.~(2013) dataset and creates a
tiff file deforestation\_year for each year desired. Take the
`treecover2000' and filter for pixels greater than 10\%. 2. `lossyear'
and `treecover2000' also need to be cropped so that pixels are only
within the boundary of the active property of that year.

\hypertarget{import-libraries}{%
\section{Import libraries}\label{import-libraries}}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{import}\NormalTok{ os}
\ImportTok{import}\NormalTok{ sys}
\ImportTok{from}\NormalTok{ pathlib }\ImportTok{import}\NormalTok{ Path}
\ImportTok{import}\NormalTok{ rasterio}
\ImportTok{from}\NormalTok{ rasterio.merge }\ImportTok{import}\NormalTok{ merge}
\ImportTok{from}\NormalTok{ rasterio.mask }\ImportTok{import}\NormalTok{ mask}
\ImportTok{from}\NormalTok{ rasterio.transform }\ImportTok{import}\NormalTok{ from\_origin}
\ImportTok{import}\NormalTok{ geopandas }\ImportTok{as}\NormalTok{ gpd}
\ImportTok{import}\NormalTok{ pandas }\ImportTok{as}\NormalTok{ pd}
\ImportTok{import}\NormalTok{ numpy }\ImportTok{as}\NormalTok{ np}
\ImportTok{import}\NormalTok{ numpy.ma }\ImportTok{as}\NormalTok{ ma}
\ImportTok{import}\NormalTok{ matplotlib.pyplot }\ImportTok{as}\NormalTok{ plt}
\end{Highlighting}
\end{Shaded}

\hypertarget{import-constants}{%
\section{Import Constants}\label{import-constants}}

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{\# Get the current working directory}
\NormalTok{current\_dir }\OperatorTok{=}\NormalTok{ os.path.abspath(}\StringTok{\textquotesingle{}\textquotesingle{}}\NormalTok{)}

\CommentTok{\# Search for the \textquotesingle{}constants.py\textquotesingle{} file starting from the current directory and moving up the hierarchy}
\NormalTok{project\_root }\OperatorTok{=}\NormalTok{ current\_dir}
\ControlFlowTok{while} \KeywordTok{not}\NormalTok{ os.path.isfile(os.path.join(project\_root, }\StringTok{\textquotesingle{}constants.py\textquotesingle{}}\NormalTok{)):}
\NormalTok{    project\_root }\OperatorTok{=}\NormalTok{ os.path.dirname(project\_root)}

\CommentTok{\# Add the project root to the Python path}
\NormalTok{sys.path.append(project\_root)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ImportTok{from}\NormalTok{ constants }\ImportTok{import}\NormalTok{ HANSEN\_LOSSYEAR\_FILEPATHS, HANSEN\_TREECOVER\_FILEPATH, STUDY\_BOUNDARY\_PATH, LUP\_YEAR\_PATHS, OUTPUT\_PATH}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{study\_boundary\_gdf }\OperatorTok{=}\NormalTok{ gpd.read\_file(STUDY\_BOUNDARY\_PATH)}

\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}rasterio.open() expects a single file path as a string, }
\CommentTok{ pass the file path string directly. Since HANSEN\_LOSSYEAR\_FILEPATHS is a list, }
\CommentTok{ you can access the file path string by indexing the list with [0].}
\CommentTok{ \textquotesingle{}\textquotesingle{}\textquotesingle{}}
\CommentTok{\# Reproject the study boundary to match the Hansen raster CRS}
\ControlFlowTok{with}\NormalTok{ rasterio.}\BuiltInTok{open}\NormalTok{(HANSEN\_LOSSYEAR\_FILEPATHS[}\DecValTok{0}\NormalTok{]) }\ImportTok{as}\NormalTok{ src:}
\NormalTok{    hansen\_crs }\OperatorTok{=}\NormalTok{ src.crs}

\CommentTok{\# Reproject the study boundary GeoDataFrame to match the Hansen raster CRS    }
\NormalTok{study\_boundary\_gdf\_reprojected }\OperatorTok{=}\NormalTok{ study\_boundary\_gdf.to\_crs(hansen\_crs)}
\CommentTok{\# Get the geometry column from the reprojected GeoDataFrame}
\NormalTok{study\_boundary\_geom\_reprojected }\OperatorTok{=}\NormalTok{ study\_boundary\_gdf\_reprojected.geometry}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{with}\NormalTok{ rasterio.}\BuiltInTok{open}\NormalTok{(HANSEN\_LOSSYEAR\_FILEPATHS[}\DecValTok{0}\NormalTok{]) }\ImportTok{as}\NormalTok{ hansen:}
\NormalTok{    hansen\_array }\OperatorTok{=}\NormalTok{ hansen.read(}\DecValTok{1}\NormalTok{)}
\NormalTok{    hansen\_crs }\OperatorTok{=}\NormalTok{ hansen.crs}
\NormalTok{    out\_transform }\OperatorTok{=}\NormalTok{ hansen.transform}
\NormalTok{    out\_meta }\OperatorTok{=}\NormalTok{ hansen.meta}
\end{Highlighting}
\end{Shaded}

\hypertarget{extract-pixels-corresponding-to-each-year-2011-2021.}{%
\section{Extract pixels corresponding to each year
(2011-2021).}\label{extract-pixels-corresponding-to-each-year-2011-2021.}}

One-hot encoding is typically used for categorical variables, where
there is no inherent ordering or numerical relationship between the
categories. In your case, the year of deforestation does have an
inherent ordering (i.e., 2007 comes before 2008) and possibly a
numerical relationship (i.e., deforestation in earlier years might
influence deforestation in later years), so treating it as a categorical
variable might not be the best approach.

However, there is a nuance in your case. If a pixel gets deforested in a
particular year, it remains deforested in all subsequent years. This
means that a pixel deforested in 2007 will also be deforested in 2008,
2009, and so on. If you use the year of deforestation as a numeric
value, you might be inadvertently suggesting that deforestation in 2008
is ``more'' or ``greater'' than deforestation in 2007, which is not
necessarily the case. Instead, you're just tracking the first year of
deforestation for each pixel.

Given this, you might consider the following approach:

Binary Encoding: For each year, create a binary raster indicating
whether deforestation occurred in that year or not. This would give you
a series of rasters with values of {[}0, 1{]} for each year.

Stacking: Stack these rasters together to create a 3D array (height x
width x time), where each layer in the third dimension corresponds to a
year. This way, the model can learn about the temporal dynamics of
deforestation.

This approach allows the model to learn from the temporal sequence of
deforestation events without misinterpreting the year of deforestation
as a numerical value. However, it does not explicitly encode the
information that once a pixel is deforested, it remains deforested in
all subsequent years. You will need to ensure that your model
architecture can capture this temporal dependency.

In the end, the choice of encoding often depends on the specifics of
your data and the model you're using, and it may be worth experimenting
with different approaches to see what works best.

Lagged features are created by shifting the original feature values
along the time dimension. They represent the values of a feature at an
earlier time step. In the context of your deforestation problem, a
lagged feature would represent whether deforestation occurred in a pixel
in the previous year(s). By including these lagged features in your
model, you allow the model to learn how deforestation in earlier years
affects deforestation in later years.

Here's a step-by-step example of creating lagged features for your
deforestation data:

Assume you have binary rasters for each year from 2001 to 2011,
indicating whether deforestation occurred in that year (1) or not (0).
You should have 11 rasters, one for each year.

To create a lagged feature with a lag of 1 year, you would shift the
rasters by 1 year in the time dimension. For example, the 2002 raster
would be shifted to 2001, the 2003 raster to 2002, and so on. The last
raster (2011) would need to be filled with zeros or dropped, as there is
no data available for 2012.

You should now have 11 rasters, where each raster represents whether
deforestation occurred in the previous year (1) or not (0). These are
the lagged features with a lag of 1 year.

Stack these new lagged rasters together with the original rasters. This
would create a 3D array (height x width x 2 * time), where each layer in
the third dimension corresponds to a year and its corresponding lagged
year.

Use this new 3D array as input to your Random Forest model. The model
will now learn the relationship between deforestation in the previous
year(s) and the current year, which may help it better capture temporal
dependencies.

In this example, I used a lag of 1 year, but you can experiment with
different lag values depending on your data and problem. For instance,
you could create lagged features for 2 or 3 years to capture longer-term
dependencies.

Note that this is just one way to introduce temporal information into a
non-temporal model like Random Forest. There might be other ways to
incorporate temporal information, and it's worth experimenting to find
the best approach for your data and problem.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}This function accepts raster data, a start year, and an end year as arguments. }
\CommentTok{The function iterates through the years within the given range and }
\CommentTok{creates a binary mask for each year where the raster values match the year. }
\CommentTok{It then stores these binary masks in a dictionary with the corresponding year }
\CommentTok{as the key.\textquotesingle{}\textquotesingle{}\textquotesingle{}}



\CommentTok{\# Extract pixels corresponding to each year (2001{-}2021)}
\CommentTok{\# This will return binary but if we want to keep the encoded value of the }
\CommentTok{\# pixelReturns pixels encoded with value of 1 and zeros as NaN.}
\CommentTok{\#if \textasciigrave{}year\_pixels[year\_pixels == 0] = np.nan\textasciigrave{} is removed then will return }
\CommentTok{\# Unique values for year 2011: [0 1]. }

\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}def extract\_pixels\_by\_year\_binary(raster\_data, start\_year, end\_year):}
\CommentTok{    year\_data = \{\}}
\CommentTok{    for year in range(start\_year, end\_year + 1):}
\CommentTok{        year\_pixels = (raster\_data == year).astype(int) }
\CommentTok{        year\_data[year] = year\_pixels}

\CommentTok{        \# Print unique values for each year}
\CommentTok{        unique\_values = np.unique(year\_pixels)}
\CommentTok{        print(f"Unique values for year \{year + 2000\}: \{unique\_values\}") \# Add 2000 to the year to get the correct year values}
\CommentTok{    return year\_data}

\CommentTok{pixels\_by\_year = extract\_pixels\_by\_year\_binary(hansen\_array, 1, 21)\textquotesingle{}\textquotesingle{}\textquotesingle{}}

\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}While iterating through the years, the function also prints unique values for }
\CommentTok{each year\textquotesingle{}s binary mask. These unique values should be either 0 or 1, }
\CommentTok{where 1 represents the pixels that have a deforestation event }
\CommentTok{for that specific year, and 0 represents the pixels that do not.\textquotesingle{}\textquotesingle{}\textquotesingle{}}


\end{Highlighting}
\end{Shaded}

Returns pixels encoded with value of corresponding year(11,12,13\ldots)
and zeros as NaN. if
\texttt{year\_pixels{[}year\_pixels\ ==\ 0{]}\ =\ np.nan} is removed
then will return {[}0 11{]}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\CommentTok{def extract\_pixels\_by\_year(raster\_data, start\_year, end\_year):}
\CommentTok{    year\_data = \{\}}
\CommentTok{    for year in range(start\_year, end\_year + 1):}
\CommentTok{        year\_pixels = (raster\_data == year).astype(int) * year}
\CommentTok{        year\_data[year] = year\_pixels}

\CommentTok{        \# Print unique values for each year}
\CommentTok{        unique\_values = np.unique(year\_pixels)}
\CommentTok{        print(f"Unique values for year \{year + 2000\}: \{unique\_values\}") \# Add 2000 to the year to get the correct year values}
\CommentTok{             }
\CommentTok{    return year\_data}

\CommentTok{pixels\_by\_year = extract\_pixels\_by\_year(hansen\_array, 11, 21)}
\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ extract\_pixels\_by\_year\_cumulative(raster\_data, start\_year, end\_year):}
\NormalTok{    year\_data }\OperatorTok{=}\NormalTok{ \{\}}
\NormalTok{    cumulative\_pixels }\OperatorTok{=}\NormalTok{ np.zeros\_like(raster\_data, dtype}\OperatorTok{=}\BuiltInTok{int}\NormalTok{)}
    
    \ControlFlowTok{for}\NormalTok{ year }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(start\_year, end\_year }\OperatorTok{+} \DecValTok{1}\NormalTok{):}
\NormalTok{        year\_pixels }\OperatorTok{=}\NormalTok{ (raster\_data }\OperatorTok{==}\NormalTok{ year).astype(}\BuiltInTok{int}\NormalTok{)}
\NormalTok{        cumulative\_pixels }\OperatorTok{+=}\NormalTok{ year\_pixels}
\NormalTok{        year\_data[year] }\OperatorTok{=}\NormalTok{ cumulative\_pixels.copy()}

        \CommentTok{\# Print unique values for each year}
\NormalTok{        unique\_values }\OperatorTok{=}\NormalTok{ np.unique(year\_pixels)}
        \BuiltInTok{print}\NormalTok{(}\SpecialStringTok{f"Unique values for year }\SpecialCharTok{\{}\NormalTok{year }\OperatorTok{+} \DecValTok{2000}\SpecialCharTok{\}}\SpecialStringTok{: }\SpecialCharTok{\{}\NormalTok{unique\_values}\SpecialCharTok{\}}\SpecialStringTok{"}\NormalTok{) }\CommentTok{\# Add 2000 to the year to get the correct year values}
    \ControlFlowTok{return}\NormalTok{ year\_data}

\NormalTok{pixels\_by\_year }\OperatorTok{=}\NormalTok{ extract\_pixels\_by\_year\_cumulative(hansen\_array, }\DecValTok{1}\NormalTok{, }\DecValTok{21}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unique values for year 2001: [0 1]
Unique values for year 2002: [0 1]
Unique values for year 2003: [0 1]
Unique values for year 2004: [0 1]
Unique values for year 2005: [0 1]
Unique values for year 2006: [0 1]
Unique values for year 2007: [0 1]
Unique values for year 2008: [0 1]
Unique values for year 2009: [0 1]
Unique values for year 2010: [0 1]
Unique values for year 2011: [0 1]
Unique values for year 2012: [0 1]
Unique values for year 2013: [0 1]
Unique values for year 2014: [0 1]
Unique values for year 2015: [0 1]
Unique values for year 2016: [0 1]
Unique values for year 2017: [0 1]
Unique values for year 2018: [0 1]
Unique values for year 2019: [0 1]
Unique values for year 2020: [0 1]
Unique values for year 2021: [0 1]
\end{verbatim}

\hypertarget{write-raster-files-for-each-year}{%
\section{Write raster files for each
year}\label{write-raster-files-for-each-year}}

write\_year\_rasters() takes four arguments: year\_data, out\_transform,
out\_meta, and output\_dir. The year\_data is a dictionary containing
binary masks for each year, out\_transform and out\_meta are the
transform and metadata extracted from the original Hansen loss year
raster, and output\_dir is the directory where the output raster files
should be saved.

Inside the function, loop through the year\_data dictionary, and for
each year, create an output file path with a filename based on the year
(e.g., `deforestation\_2001.tif'). Then, use rasterio.open() in write
mode (`w') to create a new raster file with the specified metadata.
write the binary mask data to the raster and set its transform to match
the original raster.

After defining the function, create an output directory
deforestation\_by\_year inside the OUTPUT\_PATH directory using
os.makedirs(). The exist\_ok=True parameter ensures that the function
does not raise an error if the directory already exists.

Finally, call the write\_year\_rasters() function, passing the
pixels\_by\_year dictionary, out\_transform, out\_meta, and output\_dir.
The function writes separate raster files for each year's binary mask in
the specified output directory.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Write raster files for each year}
\KeywordTok{def}\NormalTok{ write\_year\_rasters(year\_data, out\_transform, out\_meta, output\_dir):}
    \ControlFlowTok{for}\NormalTok{ year, data }\KeywordTok{in}\NormalTok{ year\_data.items():}
\NormalTok{        out\_filepath }\OperatorTok{=}\NormalTok{ os.path.join(output\_dir, }\SpecialStringTok{f\textquotesingle{}deforestation\_}\SpecialCharTok{\{}\NormalTok{year}\SpecialCharTok{\}}\SpecialStringTok{.tif\textquotesingle{}}\NormalTok{)}
        \ControlFlowTok{with}\NormalTok{ rasterio.}\BuiltInTok{open}\NormalTok{(out\_filepath, }\StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{, }\OperatorTok{**}\NormalTok{out\_meta) }\ImportTok{as}\NormalTok{ dst:}
\NormalTok{            dst.write(data, }\DecValTok{1}\NormalTok{)}
\NormalTok{            dst.transform }\OperatorTok{=}\NormalTok{ out\_transform}

\NormalTok{output\_dir }\OperatorTok{=}\NormalTok{ os.path.join(OUTPUT\_PATH[}\DecValTok{0}\NormalTok{], }\StringTok{\textquotesingle{}deforestation\_by\_year\_cumulative\textquotesingle{}}\NormalTok{)}
\NormalTok{os.makedirs(output\_dir, exist\_ok}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\NormalTok{write\_year\_rasters(pixels\_by\_year, out\_transform, out\_meta, output\_dir)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Read one of the TIF files and print its unique values}
\ControlFlowTok{with}\NormalTok{ rasterio.}\BuiltInTok{open}\NormalTok{(}\StringTok{"/Users/romero61/../../capstone/pyforest/ml\_data/output/deforestation\_by\_year\_cumulative/deforestation\_1.tif"}\NormalTok{) }\ImportTok{as}\NormalTok{ src:}
\NormalTok{    data }\OperatorTok{=}\NormalTok{ src.read(}\DecValTok{1}\NormalTok{)}
\BuiltInTok{print}\NormalTok{(}\StringTok{"Unique values in uncropped TIF:"}\NormalTok{, np.unique(data))}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
Unique values in uncropped TIF: [0 1]
\end{verbatim}

\hypertarget{extract-tree-cover-10}{%
\section{Extract Tree Cover \textgreater=
10\%}\label{extract-tree-cover-10}}

To extract pixels with 10\% and above tree cover and write the resulting
raster:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Read the tree cover raster data.
\item
  Create a binary mask for pixels with tree cover equal to or greater
  than 10\%.
\item
  Write the binary mask to a new raster file.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# Step 1: Read the tree cover raster data}
\ControlFlowTok{with}\NormalTok{ rasterio.}\BuiltInTok{open}\NormalTok{(HANSEN\_TREECOVER\_FILEPATH[}\DecValTok{0}\NormalTok{]) }\ImportTok{as}\NormalTok{ src:}
\NormalTok{    tree\_cover\_array }\OperatorTok{=}\NormalTok{ src.read(}\DecValTok{1}\NormalTok{)}
\NormalTok{    tree\_cover\_transform }\OperatorTok{=}\NormalTok{ src.transform}
\NormalTok{    tree\_cover\_meta }\OperatorTok{=}\NormalTok{ src.meta}

\CommentTok{\# Step 2: Create a mask for pixels with tree cover equal to or greater than 10\%}
\CommentTok{\textquotesingle{}\textquotesingle{}\textquotesingle{}np.where() to create a new array, masked\_array,}
\CommentTok{that contains the original tree cover values }
\CommentTok{where the condition (tree cover \textgreater{}= 10\%) is met and 0 for the other pixels. \textquotesingle{}\textquotesingle{}\textquotesingle{}}
\NormalTok{tree\_cover\_threshold }\OperatorTok{=} \DecValTok{10}
\NormalTok{masked\_array }\OperatorTok{=}\NormalTok{ np.where(tree\_cover\_array }\OperatorTok{\textgreater{}=}\NormalTok{ tree\_cover\_threshold, tree\_cover\_array, }\DecValTok{0}\NormalTok{)}

\CommentTok{\# Step 3: Write the masked array to a new raster file}
\NormalTok{output\_dir }\OperatorTok{=}\NormalTok{ os.path.join(OUTPUT\_PATH[}\DecValTok{0}\NormalTok{], }\StringTok{\textquotesingle{}tree\_cover\_10\_percent\_and\_above\textquotesingle{}}\NormalTok{)}
\NormalTok{os.makedirs(output\_dir, exist\_ok}\OperatorTok{=}\VariableTok{True}\NormalTok{)}

\NormalTok{output\_filepath }\OperatorTok{=}\NormalTok{ os.path.join(output\_dir, }\StringTok{\textquotesingle{}tree\_cover\_10\_percent\_and\_above.tif\textquotesingle{}}\NormalTok{)}
\ControlFlowTok{with}\NormalTok{ rasterio.}\BuiltInTok{open}\NormalTok{(output\_filepath, }\StringTok{\textquotesingle{}w\textquotesingle{}}\NormalTok{, }\OperatorTok{**}\NormalTok{tree\_cover\_meta) }\ImportTok{as}\NormalTok{ dst:}
\NormalTok{    dst.write(masked\_array, }\DecValTok{1}\NormalTok{)}
\NormalTok{    dst.transform }\OperatorTok{=}\NormalTok{ tree\_cover\_transform}
\end{Highlighting}
\end{Shaded}




\end{document}
